# Αναφορά project 
(ονόματα, στοιχεία, κλπ)

Δείτε το [project στο Github.](https://github.com/ZeptrodOglyvox/noobcash_omadara)

## Στόχοι
Ο στόχος του project είναι η ανάπτυξη εφαρμογής η οποία να εκτελεί σε κατανεμημένο δίκτυο ολιγάριθμων 
VMs τις τυπικές συναλλαγές ενός cryptocurrency συστήματος.

## Τεχνολογίες
- **Γλώσσα:** Python 3.7
- **Backend:** Flask 1.1.1
- **Frontend (CLI):** Click 7.1.1

Η επικοινωνία frontend και backend γίνεται μέσω http requests και χρησιμοποιείται εξ' ολοκλήρου το πρωτοκόλλο
JSON για την ανταλλαγή μηνυμάτων. Η εφαρμογή δεν χρησιμοποιεί βάση δεδομένων οπότε και δεν υπάρχει persistence
layer. Για unit/functional tests τοπικά κατά την ανάπτυξη χρησιμοποιήθηκε το pytest. Για κρυπτογραφικους
σκοπούς χρησιμοποιήθικε η βιβλιοθήκη pycryptodome.

## Προσέγγιση
Σε μεγάλο βαθμό η ανάπτυξη της εφαρμογής έγινε με την καθοδήγηση της εκφώνησης όσον αφορά στην προσφερόμενη
λειτουργικότητα, κάνοντας ορισμένες επιπλέον προσθήκες/αλλαγές με σκοπό την εξυπηρέτηση και ορισμένων πιο
ρεαλιστικών σεναρίων. Παρ' όλα αυτά δεν έχει αναπτυχθεί ή προορίζεται στην παρούσα κατάστασή της
για ιδιαίτερη χρήση πέραν της άνω, καθώς έχουν γίνει χάριν περιορισμένου χρόνου και ευκολίας πολλές επιλογές
που θυσιάζουν την ασφάλεια, το thread-safety, την αποδοτικότητα και την κλιμακωσιμότητα.

## Συνοπτική περιγραφή της ροής πληροφορίας στο backend
Το στήσιμο του δικτύου κόμβων προορίζεται να γίνει όπως περιγράφεται στην εκφώνηση.

Για την δημιουργία ενός transaction έχουν στηθεί 3 endpoints. Το πρώτο εξυπηρετεί στη σύνταξη 
ενός "εγγράφου" συναλλαγής με τα απαραίτητα στοιχεία. Το δεύτερο λαμβάνει ένα τέτοιο έγγραφο και το υπογράφει
με το private key του κόμβου. Το τρίτο δέχεται ένα υπογεγραμμένο έγγραφο και το κάνει broadcast σε όλο το δικτυο
αφού επιβεβαιώσει την εγκυρότητά του. Στη συνέχεια το έγγραφο προστίθεται στο blockchain ως unconfirmed transaction.

Για το blockchain mining έχει στηθεί ένα endpoint το οποίο όταν καλείται κάνει αυτόματα mine ένα block με 
όσα περισσότερα unconfirmed transactions μπορεί. Επιστρέφει το block στον client ως JSON. Στη συνέχεια ένα 
2ο endpoint λαμβάνει την JSON αναπαράσταση ενός προτεινόμενου block και αναλαμβάνει την επιβεβαίωση του 
και την ανακοίνωσή του στο δίκτυο. Ο client ενημερώνεται αναλόγως αν η διαδικασία ήταν επιτυχής ή αν το block ήταν invalid 
ή απορριφθέν από το δίκτυο (πχ. επειδή άλλος κόμβος πρόλαβε να κάνει mine/announce κατά τη διάρκεια της διαδικασίας.)

## Αναλυτική περιγραφή του backend
Το backend της εφαρμογής αποτελείται από:
- Μία σειρά modules που υλοποιούν σε κλάσεις python τη βασική λειτουργικότητα του blockchain και των transactions.
- API που αποτελείτα από μία σειρά Flask blueprints για τη διαχείρηση κόμβων,
τη σύνταξη/υποβολή transactions και τις λειτουργίες του blockchain.

### Blockchain Implementation
Πολλές από τις κλάσεις διαθέτουν μεθόδους to_dict() και from_dict() ως βασικό τρόπο μετακίνησης αναπαραστάσεων
των αντικειμένων τους μέσω http & JSON.

> _backend / blockchain / blockchain.py_

- Block: Στοιχείωδης κλάση που διατελεί κυρίως χρέη dictionary με μόνη επιπλέον μέθοδο την compute_hash() η
οποία υπολογίζει (αλλά δεν αναθέτει αυτόματα) το sha256 hash για τη string αναπαράσταση του αντικειμένου.

- Blockchain: Εδώ γίνεται η μαγεία. Η λίστα chain είναι ουσιαστικά η αλληλουχία των blocks. To dictionary utxos 
εξυπηρετεί ως ένα ευρετήριο για τα unspent transaction outputs στην αλυσίδα με κλειδί το public key του παραλήπτη. 
Η δημιουργία genesis block είναι προαιρετική ώστε να μπορεί να δημιουργηθει Blockchain object από dictionary 
represantation με την μέθοδο from_dict(). Προσφέρεται επίσης η δυνατότητα να εισαχθεί στο genesis block ένα
initial transaction για τους σκοπούς της άσκησης. Για την εξασφάλιση thread safety κάθε blockchain διαθέτει 
ένα re-entrant lock το οποίο κλειδώνουμε όταν γίνονται mutations στις εσωτερικές δομές δεδομένων.
  * add_block() / add_transaction(): Οι μέθοδοι αυτές λαμβάνουν υπ' οψη και διαχειρίζονται επιπλέον τα "περιεχόμενα"
  των αντίστοιχων αντικειμένων, δηλαδη transactions/utxos κ.ο.κ.

> _backend / blockchain / transactions.py_

- TransactionInput / TransactionOutput: Κλάσεις που εξυπηρετούν τον σκοπό dictionaries, δημιουργηθείσες κυρίως
για πιθανό μελλοντικό εμπλουτισμό.

- Transaction: Διαθέτει όλα τα αναμενόμενα για την άσκηση πεδία.
  * sign(): Δημιουργεί μία υπογραφή για το transaction με το δεδομένο private key που αναμένεται να είναι generated
  με τον αλγόριθμο RSA. H υπογραφή δημιουργείται με το scheme PKCS1_v1.5
  
### REST API
> _backend / \_\_init\_\_.py_

Κάθε κόμβος διατηρεί τα δεδομένα του σε global αντικείμενα (εν γένει κακή πρακτική επιπλέον της μη-μονιμότητας) 
αντί για κάποια βάση δεδομένων. Αυτά εισάγονται σε άλλα modules με την εντολή `import backend as node` ώστε να 
γίνονται "μόνιμες" αλλαγές μέσω προσβάσεων της μορφής `node.blockchain.add_block(...)`. Αρχικοποιούνται ως None
με σκοπό να δημιουργηθούν εσκεμμένα κατά το setup.

Επιπλέον περιέχεται ένα απλό app factory για το instance του flask, με registration για τα blueprints στα άλλα
modules.

- blockchain: Αντικείμενο της κλάσης Blockchain.
- network: Λίστα dicts της μορφής {node_id: ..., url: ..., public_key: ...} με τα στοιχεία όλων των κόμβων
του δικτύου.
- wallet: Αντικείμενο της κλάσης Wallet που διατηρεί μόνο τα RSA private και public keys του κόμβου.

> _backend / utils.py_

- required_fields(): Decorator για endpoints που εξυπηρετούν POST requests και απαιτούν JSON συγκεκριμένης μορφής.
- bootstrap_endpoint(): Decorator για endpoints που απαιτούν πρόσβαση μόνο από τον bootstrap κόμβο κατά το setup.

> _backend / blueprints / nodes.py_
- setup_bootstrap(): Ορίζει έναν κόμβο ως bootstrap και αρχικοποιεί γι αυτόν όλα τα αντικείμενα.
- generate_wallet(): Καλείται για να δημιουργήσει ζευγος RSA public/private keys για τον κόμβο και να θέσει το
αντίστοιχο αντικείμενο. Τα επιστρέφει επίσης για πιθανή φύλαξη του private key από τον client (δεν γίνεται ποτέ ξανα
διαθέσιμο).
- register_with_bootstrap(): Καλείται από όλους τους κόμβους δεδομένου του url που εξυπηρετεί ο bootstrap κόμβος, στον
οποίο παρέχουν τη διεύθυνσή και το public key τους.
- setup_network(): Μετά την ολοκληρωση των παραπάνω ο bootstrap κόμβος παρέχει σε όλους τους κόμβους ένα αντίγραφο
του blockchain και του ευρετηρίου network.
- get_info(): Για κάθε κόμβο μπορούμε να λάβουμε μία σειρά πληροφοριών συμπεριλαμβανομένου του balance, του public key 
και της εικόνας του για το δίκτυο.

> _backend / blueprints / transactions.py_

- create_transaction(): Σύνταξη του επιθυμητού εγγράφου transaction εφ' όσον είναι εφικτό, παρέχοντας
αυτόματα τα απαραίτητα transaction inputs από τα utxos του αποστολέα και δημιουργώντας τα κατάλληλα outputs.
(Σημ.: Είναι παραδοχή μας ότι utxos προερχόμενα από unconfirmed transactions δεν είναι διαθέσιμα, οπότε και δεν
λαμβάνονται υπ' όψη στον υπολογισμό του balance.)
- sign_transaction(): Υπογραφή του εγγράφου με το private key του κόμβου.
- submit_transaction(): Validation και verification του δεδομένου transaction με την αντίστοιχη υπογραφή,
όπως επίσης και ανακοίνωση του στο ίδιο endpoint του υπόλοιπου δικτύου για επιβεβαίωση (με χρήση του URL argument
`?broadcast={0, 1}`). Eφ' όσον όλο το δίκτυο το επιβεβαιώσει, προστίθεται στο blockchain.

> _backend / blueprints / blockchain.py_

- mine_block(): Καλεί την αντίστοιχη μέθοδο του τοπικού blockchain και παράγει ένα block με το σωστό Proof-of-Work.
- add_block(): Επιχειρεί να προσθέσει το block στο blockchain, να επιβάλλει συμφωνία μεταξύ του δικτύου και να ενημερώσει
τον κόμβο εάν το block που πρότεινε προστέθηκε ή όχι. Ο αλγόριθμος εξηγείται αναλυτικότερα στα σχόλια της συνάρτησης.
- consensus(): Καλεί την συνάρτηση get_longest_blockchain() από το module backend.utils, η οποία εντοπίζει την
μακρύτερη αλυσίδα στο δίκτυο (με επιπλέον tie-breaker condition τη λεξικογραφική διάταξη του hash του τελευταίου 
block).
